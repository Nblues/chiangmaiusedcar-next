// Service Worker ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏Ñ‡∏ä‡∏ï‡∏≤‡∏°‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏™‡∏≤‡∏Å‡∏• 2025
// Cache Strategy: Stale-While-Revalidate + Network First ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î

const CACHE_VERSION = 'v2025-1.0.0';
const STATIC_CACHE = `static-${CACHE_VERSION}`;
const DYNAMIC_CACHE = `dynamic-${CACHE_VERSION}`;
const IMAGE_CACHE = `images-${CACHE_VERSION}`;

// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á cache
const STATIC_ASSETS = ['/', '/offline.html', '/manifest.json', '/favicon.webp'];

// Cache configuration
const CACHE_CONFIG = {
  maxAge: {
    static: 365 * 24 * 60 * 60, // 1 year
    dynamic: 7 * 24 * 60 * 60, // 1 week
    images: 30 * 24 * 60 * 60, // 30 days
  },
  maxEntries: {
    dynamic: 100,
    images: 200,
  },
};

self.addEventListener('install', event => {
  console.log('üîß Service Worker: Installing version', CACHE_VERSION);

  event.waitUntil(
    (async () => {
      try {
        // ‡∏•‡∏ö cache ‡πÄ‡∏Å‡πà‡∏≤‡∏Å‡πà‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà
        await clearOldCaches();

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á static cache
        const staticCache = await caches.open(STATIC_CACHE);

        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏ü‡∏•‡πå‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
        await staticCache.addAll(STATIC_ASSETS);

        console.log('‚úÖ Service Worker: Static cache created');

        // Force activation ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        self.skipWaiting();
      } catch (error) {
        console.error('‚ùå Service Worker: Installation failed', error);
      }
    })()
  );
});

self.addEventListener('activate', event => {
  console.log('üîÑ Service Worker: Activating version', CACHE_VERSION);

  event.waitUntil(
    (async () => {
      try {
        // ‡∏•‡∏ö cache ‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        await clearOldCaches();

        // Claim ‡∏ó‡∏∏‡∏Å client ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        await self.clients.claim();

        console.log('‚úÖ Service Worker: Activated and claimed all clients');
      } catch (error) {
        console.error('‚ùå Service Worker: Activation failed', error);
      }
    })()
  );
});

self.addEventListener('fetch', event => {
  const { request } = event;
  const url = new URL(request.url);

  // ‡∏õ‡∏•‡πà‡∏≠‡∏¢‡∏ú‡πà‡∏≤‡∏ô requests ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ cache
  if (shouldSkipCache(request)) {
    return;
  }

  // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å strategy ‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏ü‡∏•‡πå
  const strategy = getStrategy(request);

  event.respondWith(handleRequest(request, strategy));
});

// Message handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏à‡∏≤‡∏Å client
self.addEventListener('message', event => {
  const { type, data } = event.data || {};

  switch (type) {
    case 'CLEAR_CACHE':
      event.waitUntil(clearAllCaches());
      break;

    case 'UPDATE_CACHE':
      event.waitUntil(updateCache(data?.paths || ['/']));
      break;

    case 'GET_CACHE_INFO':
      event.waitUntil(
        getCacheInfo().then(info => {
          event.ports[0]?.postMessage(info);
        })
      );
      break;

    case 'SKIP_WAITING':
      self.skipWaiting();
      break;

    default:
      console.log('ü§∑ Service Worker: Unknown message type', type);
  }
});

/**
 * ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ request ‡∏ï‡∏≤‡∏° strategy ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
 */
async function handleRequest(request, strategy) {
  try {
    switch (strategy) {
      case 'networkFirst':
        return await networkFirst(request);

      case 'cacheFirst':
        return await cacheFirst(request);

      case 'staleWhileRevalidate':
        return await staleWhileRevalidate(request);

      case 'networkOnly':
        return await networkOnly(request);

      default:
        return await fetch(request);
    }
  } catch (error) {
    console.error('‚ùå Service Worker: Request failed', error);
    return await getOfflineResponse(request);
  }
}

/**
 * Network First Strategy - ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å network ‡∏Å‡πà‡∏≠‡∏ô
 */
async function networkFirst(request) {
  try {
    // ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏° fetch ‡∏à‡∏≤‡∏Å network ‡∏Å‡πà‡∏≠‡∏ô
    const networkResponse = await fetch(request);

    if (networkResponse.ok) {
      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á cache ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ï‡πà‡∏≠‡πÑ‡∏õ
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, networkResponse.clone());
      return networkResponse;
    }

    throw new Error('Network response not ok');
  } catch (error) {
    // ‡∏´‡∏≤‡∏Å network ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å cache
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }

    throw error;
  }
}

/**
 * Cache First Strategy - ‡∏´‡∏≤‡∏à‡∏≤‡∏Å cache ‡∏Å‡πà‡∏≠‡∏ô ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß
 */
async function cacheFirst(request) {
  const cachedResponse = await caches.match(request);

  if (cachedResponse) {
    return cachedResponse;
  }

  // ‡∏´‡∏≤‡πÉ‡∏ô cache ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‡πÑ‡∏õ fetch ‡∏à‡∏≤‡∏Å network
  const networkResponse = await fetch(request);

  if (networkResponse.ok) {
    const cache = await caches.open(getAppropriateCache(request));
    cache.put(request, networkResponse.clone());
  }

  return networkResponse;
}

/**
 * Stale While Revalidate - ‡πÅ‡∏™‡∏î‡∏á cache ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ + ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏´‡∏•‡∏±‡∏á
 */
async function staleWhileRevalidate(request) {
  const cachedResponse = await caches.match(request);

  // Fetch ‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏´‡∏•‡∏±‡∏á (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏≠)
  const networkPromise = fetch(request)
    .then(response => {
      if (response.ok) {
        const cache = caches.open(getAppropriateCache(request));
        cache.then(c => c.put(request, response.clone()));
      }
      return response;
    })
    .catch(error => {
      console.warn('Background fetch failed:', error);
    });

  // ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô cache ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏≠ network ‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ cache
  return cachedResponse || networkPromise;
}

/**
 * Network Only - ‡πÑ‡∏°‡πà cache ‡πÄ‡∏•‡∏¢ (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö API)
 */
async function networkOnly(request) {
  return await fetch(request);
}

/**
 * ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ß‡πà‡∏≤‡∏Ñ‡∏ß‡∏£‡∏Ç‡πâ‡∏≤‡∏° cache ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
 */
function shouldSkipCache(request) {
  const url = new URL(request.url);

  return (
    request.method !== 'GET' ||
    url.pathname.startsWith('/api/revalidate') ||
    url.pathname.startsWith('/api/analytics') ||
    url.search.includes('no-cache') ||
    url.search.includes('_refresh')
  );
}

/**
 * ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å strategy ‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏ü‡∏•‡πå
 */
function getStrategy(request) {
  const url = new URL(request.url);
  const pathname = url.pathname;

  // API calls
  if (pathname.startsWith('/api/')) {
    return 'networkOnly';
  }

  // Static assets
  if (
    pathname.startsWith('/_next/static/') ||
    pathname.includes('.css') ||
    pathname.includes('.js') ||
    pathname.includes('.woff') ||
    pathname.includes('.ico')
  ) {
    return 'cacheFirst';
  }

  // Images
  if (
    pathname.includes('.webp') ||
    pathname.includes('.jpg') ||
    pathname.includes('.png') ||
    pathname.includes('.svg') ||
    url.hostname.includes('shopify.com')
  ) {
    return 'staleWhileRevalidate';
  }

  // HTML pages
  return 'networkFirst';
}

/**
 * ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å cache ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
 */
function getAppropriateCache(request) {
  const url = new URL(request.url);
  const pathname = url.pathname;

  if (
    pathname.includes('.webp') ||
    pathname.includes('.jpg') ||
    pathname.includes('.png') ||
    pathname.includes('.svg') ||
    url.hostname.includes('shopify.com')
  ) {
    return IMAGE_CACHE;
  }

  if (
    pathname.startsWith('/_next/static/') ||
    pathname.includes('.css') ||
    pathname.includes('.js')
  ) {
    return STATIC_CACHE;
  }

  return DYNAMIC_CACHE;
}

/**
 * ‡∏•‡∏ö cache ‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
 */
async function clearOldCaches() {
  const cacheNames = await caches.keys();
  const oldCaches = cacheNames.filter(
    name => name !== STATIC_CACHE && name !== DYNAMIC_CACHE && name !== IMAGE_CACHE
  );

  await Promise.all(oldCaches.map(name => caches.delete(name)));

  if (oldCaches.length > 0) {
    console.log('üóëÔ∏è Service Worker: Deleted old caches', oldCaches);
  }
}

/**
 * ‡∏•‡∏ö cache ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
 */
async function clearAllCaches() {
  const cacheNames = await caches.keys();
  await Promise.all(cacheNames.map(name => caches.delete(name)));
  console.log('üóëÔ∏è Service Worker: All caches cleared');
}

/**
 * ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï cache ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö paths ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
 */
async function updateCache(paths) {
  const cache = await caches.open(DYNAMIC_CACHE);

  for (const path of paths) {
    try {
      const response = await fetch(path);
      if (response.ok) {
        await cache.put(path, response);
        console.log('üì¶ Service Worker: Updated cache for', path);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Service Worker: Failed to update cache for', path, error);
    }
  }
}

/**
 * ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• cache
 */
async function getCacheInfo() {
  const cacheNames = await caches.keys();
  const info = {
    version: CACHE_VERSION,
    caches: [],
    totalSize: 0,
  };

  for (const cacheName of cacheNames) {
    const cache = await caches.open(cacheName);
    const keys = await cache.keys();
    info.caches.push({
      name: cacheName,
      entries: keys.length,
    });
  }

  return info;
}

/**
 * Response ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠ offline
 */
async function getOfflineResponse(request) {
  const url = new URL(request.url);

  // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö HTML pages ‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡πâ‡∏≤ offline
  if (request.headers.get('accept')?.includes('text/html')) {
    return (
      (await caches.match('/offline.html')) ||
      new Response('Offline', {
        status: 503,
        headers: { 'Content-Type': 'text/plain' },
      })
    );
  }

  // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö images ‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û placeholder
  if (request.headers.get('accept')?.includes('image/')) {
    return new Response(null, {
      status: 503,
      statusText: 'Image unavailable offline',
    });
  }

  // Default response
  return new Response('Service unavailable', {
    status: 503,
    headers: { 'Content-Type': 'text/plain' },
  });
}

console.log('üöÄ Service Worker: Loaded version', CACHE_VERSION);
